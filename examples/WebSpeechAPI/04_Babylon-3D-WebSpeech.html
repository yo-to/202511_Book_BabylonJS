<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>Babylon.js ＋ Web Speech API ＋ 3Dモデル</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <style>
      html,
      body,
      #renderCanvas {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #000;
      }
    </style>
  </head>
  <body>
    <button id="mic" title="音声認識の開始/停止">話す</button>
    <button id="sayHello" title="TTSデモ">読み上げテスト</button>
    <canvas id="renderCanvas" aria-label="表示領域"></canvas>

    <script>
      (async () => {
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        window.addEventListener("resize", () => engine.resize());

        const $mic = document.getElementById("mic");
        const $say = document.getElementById("sayHello");

        const createScene = async () => {
          const scene = new BABYLON.Scene(engine);
          scene.clearColor = new BABYLON.Color4(0.03, 0.05, 0.08, 1);

          const camera = new BABYLON.ArcRotateCamera(
            "cam",
            -Math.PI / 2.0,
            1.1,
            8,
            BABYLON.Vector3.Zero(),
            scene
          );
          camera.attachControl(canvas, true);
          camera.wheelPrecision = 50;
          camera.lowerBetaLimit = 0.4;
          camera.upperBetaLimit = 1.4;
          camera.minZ = 0.2;

          new BABYLON.HemisphericLight(
            "hemi",
            new BABYLON.Vector3(0.1, 1, 0.2),
            scene
          );
          const env = scene.createDefaultEnvironment({
            createSkybox: true,
            skyboxSize: 120,
            createGround: true,
            groundSize: 40,
          });
          if (env && env.ground) {
            env.ground.position.y = 0;
            env.ground.receiveShadows = true;
          }

          const dirLight = new BABYLON.DirectionalLight(
            "dir",
            new BABYLON.Vector3(-0.5, -1, -0.3),
            scene
          );
          dirLight.position = new BABYLON.Vector3(10, 15, 10);
          const shadowGen = new BABYLON.ShadowGenerator(2048, dirLight);
          shadowGen.usePercentageCloserFiltering = true;

          const { meshes } = await BABYLON.SceneLoader.ImportMeshAsync(
            "",
            "https://playground.babylonjs.com/scenes/Dude/",
            "Dude.babylon",
            scene
          );
          const dude = meshes[0];
          meshes.forEach((m) => {
            m.receiveShadows = true;
            shadowGen.addShadowCaster(m, true);
          });

          const pivot = new BABYLON.TransformNode("pivot", scene);
          dude.parent = pivot;

          const bbox = dude.getHierarchyBoundingVectors(true);
          const rawHeight = bbox.max.y - bbox.min.y;
          const targetHeight = 1.8;
          const scale = targetHeight / rawHeight;
          dude.scaling.scaleInPlace(scale);
          dude.position.y += -bbox.min.y * scale;

          pivot.rotation = new BABYLON.Vector3(0, Math.PI, 0);
          const INITIAL_Z = -1.5;
          pivot.position = new BABYLON.Vector3(0, 0, INITIAL_Z);

          const animate = (
            target,
            property,
            keys,
            durationMs = 1000,
            loopMode = BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT,
            easing = null
          ) => {
            const fps = 60;
            const totalFrames = (durationMs / 1000) * fps;
            const lastT = keys[keys.length - 1][0] ?? 1;
            const lastFrame = lastT * totalFrames;

            const anim = new BABYLON.Animation(
              `anim_${property}_${Date.now()}`,
              property,
              fps,
              BABYLON.Animation.ANIMATIONTYPE_FLOAT,
              loopMode
            );
            anim.setKeys(
              keys.map(([t, v]) => ({ frame: t * totalFrames, value: v }))
            );
            if (easing) anim.setEasingFunction(easing);

            return new Promise((resolve) => {
              const animatable = scene.beginDirectAnimation(
                target,
                [anim],
                0,
                lastFrame,
                loopMode !== BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT,
                1.0,
                () => resolve()
              );
              animatable.onAnimationEnd = () => resolve();
            });
          };
          const smooth = () => {
            const e = new BABYLON.CubicEase();
            e.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT);
            return e;
          };

          const spin360 = async () => {
            await animate(
              pivot.rotation,
              "y",
              [
                [0, pivot.rotation.y],
                [1.0, pivot.rotation.y + Math.PI * 2],
              ],
              1000,
              BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT,
              smooth()
            );
          };

          const moveToZ = async (z, d = 800) => {
            await animate(
              pivot.position,
              "z",
              [
                [0, pivot.position.z],
                [1, z],
              ],
              d,
              BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT,
              smooth()
            );
          };

          const state = { speaking: false, voice: null, listening: false };
          const speak = (
            text,
            opt = { lang: "ja-JP", rate: 1.0, pitch: 1.0 }
          ) => {
            if (!("speechSynthesis" in window)) return;
            window.speechSynthesis.cancel();
            const uttr = new SpeechSynthesisUtterance(text);
            uttr.lang = opt.lang || "ja-JP";
            uttr.rate = opt.rate ?? 1.0;
            uttr.pitch = opt.pitch ?? 1.0;
            if (state.voice) uttr.voice = state.voice;
            window.speechSynthesis.speak(uttr);
          };
          const pickVoice = () => {
            const voices = window.speechSynthesis
              ? window.speechSynthesis.getVoices()
              : [];
            const ja = voices.find(
              (v) => v.lang && v.lang.toLowerCase().startsWith("ja")
            );
            state.voice =
              ja || voices.find((v) => v.default) || voices[0] || null;
          };
          if ("speechSynthesis" in window) {
            window.speechSynthesis.onvoiceschanged = pickVoice;
            pickVoice();
          }

          const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
          let recognizer = null;

          const startListen = () => {
            if (!SR) {
              speak("このブラウザは音声認識に未対応です。");
              return;
            }
            if (!recognizer) {
              recognizer = new SR();
              recognizer.lang = "ja-JP";
              recognizer.interimResults = false;
              recognizer.continuous = false;
              recognizer.onresult = (e) => {
                const text = e.results[0][0].transcript.trim();
                onCommand(text);
              };
              recognizer.onstart = () => {
                state.listening = true;
              };
              recognizer.onend = () => {
                state.listening = false;
              };
              recognizer.onerror = (ev) => {
                speak("認識エラー: " + (ev.error || "unknown"));
              };
            }
            if ("speechSynthesis" in window) window.speechSynthesis.cancel();
            try {
              recognizer.start();
            } catch (_) {}
          };
          const stopListen = () => {
            try {
              recognizer && recognizer.stop();
            } catch (_) {}
          };

          // 特定のコマンド3つのみに反応するようにする
          const includesAny = (s, arr) => arr.some((k) => s.includes(k));
          const onCommand = async (raw) => {
            const s = raw.replace(/\s+/g, "");
            let replied = false;
            console.log("認識結果:", s);

            if (
              includesAny(s, ["回って", "まわって", "スピン", "回転"])
            ) {
              speak("回ります。");
              await spin360();
              replied = true;
            } else if (
              includesAny(s, ["近づいて", "寄って", "ちかづいて", "近く"])
            ) {
              speak("少し近づきます。");
              await moveToZ(INITIAL_Z - 1.6, 800);
              replied = true;
            } else if (
              includesAny(s, [
                "遠ざかって",
                "とおざかって",
                "下がって",
                "さがって",
                "バック",
              ])
            ) {
              speak("少し下がります。");
              await moveToZ(INITIAL_Z + 2.4, 800);
              replied = true;
            }

            if (!replied) {
              speak(
                `『${raw}』ですね。今は「回って」「近づいて」「遠ざかって」に対応しています。`
              );
            }
          };

          $mic.addEventListener("click", () => {
            state.listening ? stopListen() : startListen();
          });
          $say.addEventListener("click", () =>
            speak(
              "読み上げのテストです。音声認識で対応しているコマンドは、『回って』『近づいて』『遠ざかって』の3つです。"
            )
          );

          speak(
            "準備完了です。『話す』ボタンを押してマイクに話しかけてください。"
          );

          // Escキーでカメラリセット
          window.addEventListener("keydown", (e) => {
            if (e.key === "Escape") {
              camera.setTarget(BABYLON.Vector3.Zero());
              camera.alpha = -Math.PI / 2.0;
              camera.beta = 1.1;
              camera.radius = 8;
            }
          });

          return scene;
        };

        const scene = await createScene();
        engine.runRenderLoop(() => scene.render());
      })();
    </script>
  </body>
</html>
